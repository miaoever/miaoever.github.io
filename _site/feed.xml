<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title></title>
    <description>借我瞻前与顾后，借我执拗如少年</description>
    <link>feed.xml/</link>
    <atom:link href="feed.xml/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Sun, 25 Jul 2021 23:49:28 -0700</pubDate>
    <lastBuildDate>Sun, 25 Jul 2021 23:49:28 -0700</lastBuildDate>
    <generator>Jekyll v4.2.0</generator>
    
      <item>
        <title>λ-演算与编码</title>
        <description>&lt;h4 id=&quot;历史&quot;&gt;历史&lt;/h4&gt;
&lt;p&gt;λ-演算(λ-calculus)最早由阿隆索.邱奇(Alonzo Church)提出,被看作是一套用于研究函数定义、函数应用和递归的形式系统，用来证明可确定性问题。说到邱奇，他正是大名鼎鼎的阿兰.图灵(Alan Turning)的博士生导师。而邱奇的λ-演算与图灵的图灵机被证明具有等价的计算能力。 John McCarthy 在1960年以λ-演算为基础开发了 Lisp 语言，进而使得λ-演算成为函数式编程乃至计算机程序语言的理论基础。 本文不会给出诸如 β-归约 或是 α-变换 等一些概念的形式化定义，而是会将其思想融入到具体编码(encoding)或者运算的过程中。 基本元素&lt;/p&gt;

&lt;p&gt;λ-演算主要由以下几个元素组成：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;变量, 例如, v, foo&lt;/li&gt;
  &lt;li&gt;匿名函数, 例如, λx, 表示一个参数为 x 的匿名函数.&lt;/li&gt;
  &lt;li&gt;函数的应用(application), 例如 λx.x+1, 表示一个参数为 x 的匿名函数,其函数体为 x+1.&lt;/li&gt;
  &lt;li&gt;如果我们写成 BNF 的形式，一条λ-演算表达式可以写作：&lt;/li&gt;
&lt;/ul&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;exp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;  &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;var&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;  &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;exp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;exp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;  &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;λ&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;var&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;exp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;   &lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;此外，在λ-演算中，一切皆是函数，无论是数字还是普通变量其实都是一个个的函数，正所谓函数即变量，变量即函数，因此我们很自然的能够将函数作为参数进行传递（如同我们在计算机程序语言中传递变量一样）。接下来我们会看到，通过以上几条简单的语法元素，是如何构成λ-演算强大的表达能力的。 数字编码&lt;/p&gt;

&lt;p&gt;一种常见的自然数的递归定义如下：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;零&lt;/li&gt;
  &lt;li&gt;某一个自然数的后继&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;所以，我们只要能形式化的表述『零』以及『后继』这两个概念，就能对所有自然数进行定义。对『零』和『后继』的编码方式有很多，这里我们介绍一种称为邱奇数(church numberal)的编码方式。 在邱奇数编码的定义中，将数看做是一个函数 ƒ 对变量 x 的作用，例如数字 0 表示函数 ƒ 对 x 进行了 0 次作用，数字 n 表示函数 ƒ 对变量 x 进行了 n 次作用。由此，写成λ-演算表达式的形式：&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;λƒ&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;λx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;  
&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;λƒ&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;λx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;  
&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;λƒ&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;λx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;  
&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;λƒ&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;λx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;  
    &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;以 0 为例讲解一下λ-演算的作用过程，由于λ-演算约定一个匿名函数只能有一个参数，而由上文邱奇数对数的约定可以看出，要表达一个自然数，我们需要两个参数：函数 ƒ 以及变量 x 。由上面的式子可以看出，我们在外层定义了一个匿名函数其参数为 ƒ (即 λƒ)，与此同时该匿名函数的返回值又是另一个匿名函数（λx），这个内层的匿名函数的参数为 x，返回值为 x 本身。由此我们实现了接收 ƒ 和 x 两个参数的目的；而这种过程有一个专门的名字进行描述，称为 柯里化(currying)。 还记得我们在文章开头所说：『函数即变量，变量即函数』么，这里我们把函数 ƒ 作为匿名函数参数进行传递，在函数式语言中，这称为高阶函数(high order function)。 总结起来，任意自然数 n 是一个有两个参数的匿名函数(参数分别为 ƒ 和 x)。为了便于更直观的理解上述函数，我们可以用可读性更高的程序语言来表示相同的过程：&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;zero&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;  
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;one&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;  
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;two&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;  
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;我们再来看看如何对『后继』进行编码。在自然数中，任意自然数 n 的后继即为 n+1。回到邱奇数的定义，一个数代表函数 ƒ 对变量 x 的作用，对任意数字 n ，表示函数 ƒ 对变量 x 进行了 n 次作用，那么，自然数 n+1 表达了什么呢？一方面我们很容易想到 n+1 是 ƒ 对 x 的 n+1 次作用，另一方面，n+1 也表示对数字 n 再进行一次 ƒ 的作用(apply)，换句话说，就是将函数 ƒ 作用于 n 。 有了上面的的描述，我们很容易将『后继』表示如下：&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt; &lt;span class=&quot;n&quot;&gt;successor&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;λn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;λf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;λx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;可见，『后继』是一个有三个参数的匿名函数(参数分别为n, f, x)，它的返回值为 ƒ 对数 n 的一次作用，即为 n 的后继（想一想，在『后继』的表达式中，是如何表达数字 n 的）。 由此，我们完成了对整个自然数的定义，在这之上，我们就能进一步定义更多的操作，比如对于加法，我们输入任意两个自然数 m 和 n，希望得到 m+n:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt; &lt;span class=&quot;n&quot;&gt;add&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;λn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;λm&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;successor&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h4 id=&quot;布尔值编码&quot;&gt;布尔值编码&lt;/h4&gt;
&lt;p&gt;对于布尔值的变量，只有在条件判断语句中(如 if)，才能体现出其值(true or false)的意义，所以我们先来定义 if 表达式。if 表达式通常有如下的形式：&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;condition&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;  
  &lt;span class=&quot;n&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;exp&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;  
  &lt;span class=&quot;n&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;exp&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;可以看出，if 表达式有三个输入参数：condition, true-exp, false-exp, 通过对条件变量 condition 进行判断，分别选择 true-exp 或是 false-exp 作为返回值。 根据上面的定义，我们可以由此得出 if 表达式对应的形式化定义： if := λv.λt.λf.v t f&lt;/p&gt;

&lt;p&gt;用自然语言来解释，就是 if 作为一个函数，输入三个参数：v, t, f, 其返回值为函数 v 作用于 t f 之上的结果（即t 和 f 作为 v 的两个参数输入到 v 中）。 很容易我们就能将 t 对应于之前提到的 true-exp，f 对应于 false-exp，v 则对应 condition 。显然，v 应该是一个布尔值函数，即 true 函数 或 false 函数，我们将 t 和 f 作为 v 的两个参数输入，如果 v 为 true 函数，其将第一个参数（即 t）作为返回值，若 v 为 false 函数，则输出第二个参数（即 f）。由此我们得到 true 和 false 的定义：&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span class=&quot;n&quot;&gt;true&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;λx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;λy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;  
&lt;span class=&quot;n&quot;&gt;false&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;λx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;λy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;  &lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;以上就是λ-演算中对于 true 和 false 的定义。此外，细心的读者可能会发现 false 的定义和 0 的定义实质上是相同的，所以在程序语言中 0 和 false 都代表『假』值是一种合理的设计。 此外，我们还可以进一步定义一些常见的逻辑函数：&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span class=&quot;ow&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;λx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;λy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;false&lt;/span&gt;  
&lt;span class=&quot;ow&quot;&gt;or&lt;/span&gt;  &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;λx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;λy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;true&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;  
&lt;span class=&quot;ow&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;λx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;false&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;true&lt;/span&gt;  &lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;请读者自行思考、推导、验证上述表达式的正确性。&lt;/p&gt;

&lt;h4 id=&quot;序对编码&quot;&gt;序对编码&lt;/h4&gt;

&lt;p&gt;熟悉 Lisp 以及其方言（如 scheme ）的读者对序对(pair)应该不陌生，简单的说，我们称 M 和 N 的有序集合为一个序对，记为。对于序对，我们有三个操作：创建序对(mkpair),提取第一个元素(fst)，提取第二个元素(snd)。例如：&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span class=&quot;n&quot;&gt;fst&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mkpair&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;M&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;M&lt;/span&gt;  
&lt;span class=&quot;n&quot;&gt;snd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mkpair&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;M&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;  &lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;序对类型的本质，是由 mkpair 构造，并且能根据选择 fst 或是 snd 返回序对的首或尾元素。说到根据某个条件选择第一个元素或是第二个元素，这不正是我们上文所介绍的布尔值编码所对应的过程吗？如果把构造序对(mkpair)看做是构造一个 if 表达式，而选择第一个还是第二个元素作为 condition 用于判断，若 condition 为 fst（对应布尔值的 true），返回第一个元素，若为 snd (对应 false)，则返回第二个元素，我们就能将对序对的编码完全对应到对布尔值的编码之上，&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span class=&quot;n&quot;&gt;mkpair&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;λx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;λy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;λs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;  
&lt;span class=&quot;n&quot;&gt;fst&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;λp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;true&lt;/span&gt;  
&lt;span class=&quot;n&quot;&gt;snd&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;λp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;false&lt;/span&gt;  &lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

</description>
        <pubDate>Fri, 26 Jul 2013 03:18:00 -0700</pubDate>
        <link>feed.xml/intro-to-lambda-calculus</link>
        <guid isPermaLink="true">feed.xml/intro-to-lambda-calculus</guid>
        
        
      </item>
    
      <item>
        <title>浅谈 Unix I/O 模型</title>
        <description>&lt;p&gt;在实际应用中，数据操作通常分为输入和输出，那么以输入为例，在操作系统中，一个数据的输入通常分为以下两个过程： a. 等待数据准备好. b. 将准备好的数据从内核拷贝到用户空间. 下面我们将会分别讨论 I/O 模型中的两个大类，即 同步 I/O 与 异步 I/O。&lt;/p&gt;

&lt;h4 id=&quot;1-同步-io&quot;&gt;1. 同步 I/O&lt;/h4&gt;

&lt;p&gt;同步与异步 I/O 的最大不同，就是在在进行数据复制时（即过程 b ），所有的同步 I/O 模型均会发生阻塞。进一步来看，又可以根据在等待数据准备好时( 过程 a )是否发生阻塞，将同步 I/O 分为：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;阻塞 I/O ( blocking I/O )&lt;/strong&gt;. 其在过程 a 与 过程 b 中均会阻塞。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;非阻塞 I/O ( non-blocking I/O )&lt;/strong&gt;.  过程 a 不阻塞， 过程 b 阻塞。在过程 a 阶段若无数据准备好，则内核立即返回 EWOULDBLOCK 错误 (通过设置 errno)，用户进程立即返回因而不会发生阻塞。此时，用户进程可以不断的通过轮询( polling )的方式查询数据是否准备好。一旦数据准备就绪， 进程便会进入阻塞模式（即阻塞于过程 b ），进行数据的拷贝直至完成。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;I/O 复用( I/O multiplexing, event-driven )&lt;/strong&gt;.  I/O 复用有时又被称为 事件驱动 I/O, 它的最大优势在于，我们可以将感兴趣的多个I/O事件（更精确的说，应该是 I/O 所对应的文件描述符）注册到 select/poll/epoll/kqueue 之中某一个系统调用上（很多时候，这些系统调用又被称为多路复用器。假设此时我们选择了 select() ）。此后，调用进程会阻塞在 select() 系统调用之上（而不是阻塞在真正的 I/O 系统调用（如 read(), write() 等）上）。select() 会负责监视所有已注册的 I/O 事件，一旦有任意一个事件的数据准备好，那么 select() 会立即返回，此时我们的用户进程便能够进行数据的复制操作（过程 b ）。总而言之，I/O 复用的优点就在于可以同时等待多个I/O事件；而缺点是会进行两次系统调用（一次 select(), 一次 read() ）。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;通过上面的讨论可以清楚的看到，同步 I/O 总会有阻塞的过程，这就是“同步”最本质的特征。&lt;/p&gt;

&lt;h4 id=&quot;2异步-io&quot;&gt;2.异步 I/O&lt;/h4&gt;

&lt;p&gt;如前文所说，异步 I/O 的最大特点在于在过程 a 和过程 b 中， 用户进程均不阻塞。 用户进程告知内核启动某一 I/O 操作， 并让内核全权代为执行（包括等待数据及拷贝数据至用户空间），此后用户进程可以立即执行其它的任何操作。等到所有 I/O 过程执行完成后， 内核会通知用户程。由此可见，在整个过程中，用户进程均不阻塞。 以上谈到了 Unix 系统当中 I/O 操作的具体执行方式。在此基础之上, 我们介绍两种常见的 I/O 事件处理模型。事件处理模型的意义在于我们从更宏观的角度来看待实际应用中如何来处理 I/O 事件。我们还是以一个读操作( read() )为例, 根据 I/O 操作是基于同步或异步，分别介绍如下两种模型：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Reactor 模式( event loop )&lt;/strong&gt;. 基于同步 I/O&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;将要读的文件描述符注册到多路复用器中（如 select(), poll(), epoll() ）。&lt;/li&gt;
      &lt;li&gt;调用进程阻塞在多路复用器上，其等待已注册的任意一个 I/O 事件发生。&lt;/li&gt;
      &lt;li&gt;一旦事件发生(即文件描述符变为可读， 多路复用器返回)， 将调用用户提供的事件处理函数( event handler)进行实际的 I/O 复制操作。&lt;/li&gt;
      &lt;li&gt;读取完成后，事件处理函数可以对数据进行进一步的处理。&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Proactor 模式&lt;/strong&gt;，基于异步 I/O&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;用户进程启动一个异步读文件操作， 同时将该操作注册到多路复用器上。多路复用器并不关心文件是否可读，而只关心该异步操作是否完成。&lt;/li&gt;
      &lt;li&gt;整个异步读文件操作由内核完成，用户进程不需要关心。多路复用器阻塞以等待某个完成通知的到达。&lt;/li&gt;
      &lt;li&gt;当内核完成了整个读文件操作 – 即数据已经准备好，并已由内核复制到了用户事先提供的缓冲区后 – 通知多路复用器读操作已完成。&lt;/li&gt;
      &lt;li&gt;多路复用器再调用相应的事件处理函数( event handler )处理位于用户缓冲区的数据。&lt;/li&gt;
    &lt;/ol&gt;

    &lt;p&gt;由此我们可以看到 Reactor 与 Proactor 最大的区别在于数据准备好后，是由谁来将这些数据复制到用户空间中的缓存区之中。Reactor 由于调用的是同步 I/O ， 所以当多路复用器由于数据准备好而返回之后，将会由用户的事件处理函数自行将数据复制到用户缓冲区中， 而 Proactor 由于调用的是异步 I/O ,  因此等待及复制数据均由内核完成，用户进程只需要等待内核的完成通知，此后由事件处理函数对已在缓冲区中的数据进行进一步的处理。 由于 Proactor 模型需要操作系统提供异步 I/O 的支持，要求较高，故基于上面所描述的思想， 我们可以用 Reactor 模型来模拟 Proactor (只需要用户额外提供用户缓冲区来存放读取出的数据)。简单来说，就是由多路复用器来代替用户进程来完成实际的 I/O 复制操作。 在 Reactor 模型的第 3 步中，当某个文件描述符可读使得多路复用器返回之后，多路复用器执行一个非阻塞读操作， 将数据从内核读至用户提供的缓冲区中，此操作完成后通知（调用）对应的事件处理函数，告知其 I/O 操作已完成。 这样一来，我们就可以在各种系统中（无论支持异步 I/O 与否）均对外提供统一的 Proactor 模型接口，而对用户隐藏其后的具体实现细节。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;参考资料&quot;&gt;参考资料&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;&amp;lt; Unix network programming &amp;gt;, Chapter 6&lt;/li&gt;
  &lt;li&gt;Comparing Two High-Performance I/O Design Pattern&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Mon, 10 Jun 2013 03:18:00 -0700</pubDate>
        <link>feed.xml/talk-about-unix-io-model</link>
        <guid isPermaLink="true">feed.xml/talk-about-unix-io-model</guid>
        
        
      </item>
    
  </channel>
</rss>
