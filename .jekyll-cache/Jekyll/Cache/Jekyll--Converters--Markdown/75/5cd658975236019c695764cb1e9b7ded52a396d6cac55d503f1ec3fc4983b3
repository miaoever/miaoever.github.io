I"4<p>sheva.js 是业余时间实现的一个简单的 Parser Combinator Liabrary（解析器组合子）。其能够通过若干简单的解析器(parser)，进而组合实现功能更加强大的解析器。具体可以参看 sheva.js README 中所描述的一个计算器的例子。</p>

<blockquote>
  <p>组合子(combinator)是函数式编程里面的重要思想。如果说OO是归纳法（分析归纳需求，然后根据需求分解问题，解决问题），那么 “面向组合子”就是“演绎法”。通过定义最基本的原子操作，定义基本的组合规则，然后把这些原子以各种方法组合起来。</p>
</blockquote>

<p>面向组合子(co)编程的难度在于，需要将待问题正交分解为若干子模块（组合子），然后通过这些正交组合子的任意组合完成对问题的完整建模。co 通常充分利用了函数式语言中函数作为 first-class citizen 的地位，将逻辑、功能均抽象为函数，并通过其的组合实现所需的功能。</p>

<p>解析器组合子(parser combinator)可以说是最常见的组合子应用。区别于传统的通过自动机(automation)来实现解析器的方式，解析器组合子通过若干简单的解析器不断组合成功能更加复杂的解析器。从形式上来说，解析器组合子的输入是若干解析函数(parse function)，输出是一个功能更复杂的解析函数。</p>

<p>组合子通常使用支持函数式编程特别是支持将函数作为第一类类型的语言来实现（因为在实现上，一个组合子就可以看作是一个函数），其支持将函数作为参数进行传递、作为返回值进行返回，大大简化了实现的难度。而对于主流的支持面向对象的语言来说，实现组合子也几乎没有任何障碍。对于函数式语言与面向对象语言来说，闭包(closure)和对象是两个占据核心位置的概念，</p>

<blockquote>
  <p>objects are merely a poor man’s closures</p>
</blockquote>

<p>对于闭包来说，在描述上通常称为“函数以及其所关联的一个局部作用域”，而我更倾向于描述成“带有状态的函数”，这样的措词能够强调闭包是一个函数，其次是区别于一般函数，闭包带有通过作用域所保存的状态。而对于面向对象语言中的对象(object)来说，功能通过成员函数来实现，状态则通过对象中的成员变量来保持。在这个视角下，类和闭包的区别仅仅在于闭包作为一个函数是 invokable 的，而对于对象来说则必须通过“对象名.成员函数()”的方式来进行调用。所以，通过诸如 C++/Java 这样的支持面向对象的语言来实现组合子几乎没有任何的障碍。</p>

<p>更进一步，在 C++11 标准中，Funtor(仿函数)已经成为标准库的一部分。在标准库中，std::function 是一个类，其对应的对象和其它所有对象一样具有成员函数、成员变量，可以作为函数参数以及返回值；所不同的是，其通过重载函数调用符号‘()’ 来实现了对象的 invokable, 使得 std::function 类型的对象在形式上能够如同函数一样被直接调用。在我的实际使用中，Funtor的引入使得整个语言具有更强大的表达能力。</p>

<p>面向组合子编程是一种非常强大的问题建模方式，更丰富的内容可以参考 ajoo 的经典系列文章<论面向组合子程序设计方法> 。</论面向组合子程序设计方法></p>

<p>Sheva.js</p>

<p>Github: <a href="https://github.com/miaoever/sheva">https://github.com/miaoever/sheva</a></p>
:ET